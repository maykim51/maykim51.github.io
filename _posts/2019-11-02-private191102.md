---
title: "TIL - DS and Alg."
categories: 
    - private
tags: 
    - programminglanguage
    - algorithm
---

**2019/11/01~**
  
#programminglanguage #algorithm


âœ¨   
ðŸ’¦  


## Functional Language vs. Imperative Language
[í•¨ìˆ˜í˜• í”„ë¡œê·¸ëž˜ë°ê³¼ ëª…ë ¹í˜• í”„ë¡œê·¸ëž˜ë°](https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/linq/functional-programming-vs-imperative-programming)
* OOP | Impertative | ì ˆì°¨ì  | Iterative Algorithms  


## 1. ìžë£Œêµ¬ì¡° Data Structure
### Hashtable í•´ì‹œí…Œì´ë¸”
Search, Insertion, Deletion **O(1)** at best ~ **O(n)** at worst  
*ë‹¨ì–´ê°€ K ê¸¸ì´ë©´ hash tableë„ searchì— O(k) ê°€ í•„ìš”í•¨*   

**êµ¬í˜„**
- Linked List  
- Hash Code Function  
OR  
- Balanced Binary Search Tree(Search O(logN))  
  

### Linked List ì—°ê²°ë¦¬ìŠ¤íŠ¸
Access / Search : O(n)  
**Insertion / Delete: O(1)**  
  
* Runner (a.k.a ë¶€ê°€ í¬ì¸í„°)  
* ëŒ€ë¶€ë¶„ì˜ LL ë¬¸ì œëŠ” Recursiveë¡œ í’€ ìˆ˜ ìžˆë‹¤  
  
  
### Stack & Queue ìŠ¤íƒê³¼ í
Access and Search: O(n)
**Insertion and Deletion: O(1)**  
  
* Implementation  
    * Stack =  Array in LIFO  
        - pop, push, peek, isEmpty
    * Queue = Array in FIFO   
        - add, remove, peek, isEmpty  
  
* Usage  
    * Stack: Backtrack, Recursion, Convert recursion to iterative
    * Queue: BFS, Cache  


### Tree  
**LOG(N)** ì „ë¶€ë‹¤!!
* Structure: 
    - One root node
    - root node has 0 or more children nodes
    - all nodes has 0 or more children nodes
    - No Cycle  
    - (Option) has reference to parent node  

* Types of Tree
    - Binary vs. BST (search -> **left < root < right** )  
    - Balanced ê· í˜• íŠ¸ë¦¬ : ê°€ìž¥ ì•„ëž˜ìª½ ë ˆë²¨ì„ ì œì™¸í•˜ê³  ëª¨ë“  ë ˆë²¨ì—ì„œ ë…¸ë“œê°€ ê°€ë“ ì°¬ ìƒíƒœ
    - Complete binary tree ì™„ì „ì´ì§„íŠ¸ë¦¬: ëª¨ë“  ë†’ì´ì—ì„œ ë…¸ë“œê°€ ê½‰ ì°¨ ìžˆëŠ” ì´ì§„ íŠ¸ë¦¬ (ë§ˆì§€ë§‰ ì¤„ì€ ë‹¤ ì•ˆ ì°¨ìžˆì–´ë„ ë˜ì§€ë§Œ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì±„ì›Œì ¸ìžˆì–´ì•¼ í•¨)
    - Full binary tree ì „ ì´ì§„íŠ¸ë¦¬: ìžì‹ì´ 0 or 2
    - perfect binary tree í¬í™” ì´ì§„íŠ¸ë¦¬: ê·¸ëƒ¥ ë‹¤ ì°¨ ìžˆëŠ” íŠ¸ë¦¬ 


* Traversal of Tree  
    - pre, in, post order  
  

### Heap
* ê° ë…¸ë“œì˜ ê°’ < ìžì‹ë“¤ì˜ ê°’ ë³´ë‹¤ ìž‘ì€ ì™„ì „ ì´ì§„ íŠ¸ë¦¬
* implementation: **insert(), extract_min()**
* insertion: ì˜¤ë¥¸ìª½ ë§¨ ì•„ëž˜ë¡œ ì‚½ìž…í•˜ê³  ì œìžë¦¬ë¥¼ ì°¾ì•„ê°  
* extract_min: ë£¨íŠ¸ë¥¼ ë¹¼ê³  ê·¸ ìžë¦¬ì— ë§¨ ì˜¤ë¥¸ìª½ ì•„ëž˜ ë…¸ë“œë¥¼ ë„£ê³  ì œìžë¦¬ë¥¼ ì°¾ì•„ê°  
  


### Trie  
* Search O(k) / Insertion O(k) : k is an average length of the string  
  

### Graph
Treeë„ Graphì˜ í•œ ì¢…ë¥˜ (Tree < Graph )  
  
* implementaion
    - Adjacency list  
    - Adjacency matrix(ëœ íš¨ìœ¨ì )  


## 2. ì•Œê³ ë¦¬ì¦˜ Algorithm
### DFS, BFS - for GRAPHs  
DFS | BFS 
:--- | :---
* ëª¨ë“  ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê³ ìž í• ë•Œ  
* ë” ê°„ë‹¨í•¨  
* visited ì‚¬ìš©  \
| \
*  ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°  
* QUEUE ì‚¬ìš©   

* DFSë¡œ graph traverse í• ë•ŒëŠ”, ì–´ë–¤ ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆì—ˆëŠ”ì§€ visitedë¥¼ ê¼­ ê²€ì‚¬í•´ì•¼í•¨  
* BFS is NOT recursive.  Uses QUEUE.  
 



## 3. Concept
